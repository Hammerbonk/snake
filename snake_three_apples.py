#подключаем библиотеки, с которыми мы будем работать
import pygame
import time
import random

#инициализация; необходимо для корректной работы всех модулей данной библиотеки
pygame.init()

#необходимые цвета, которые мы будем использовать в ходе написания кода
start_screen_back = (50, 205, 50)
snake_text = (0, 128, 0)
continue_quit_text = (0, 90, 0)
back_moccasin = (255, 228, 181)
score_font_brown = (139, 69, 19)
gameover_font_blue = (65, 105, 225)
snake_green = (0, 100, 0)
apple_red = (255, 0, 0)
apple_gold = (255, 165, 0)
apple_green = (35, 129, 0)

#задаём размеры,
window_x = 720
window_y = 480

#cоздаём окно размером заданных чисел
screen = pygame.display.set_mode((window_x, window_y))

#и его название
pygame.display.set_caption('Grisha')

#ставим змейку в середину экрана, и для этого разделяем указанные значения пополам
snake_x = window_x / 2
snake_y = window_y / 2

#размер блока змейки
snake_size = 10

#длина змейки
snake_length = 4

#список, в котором хранятся все её блоки
snake_blocks = []

#скорость змейки (используем для фпс)
snake_speed = 15

#фпс (кадры в секунду), без них игра моментально закончится, так как не будет задана скорость отображения
#(показатель того, насколько плавно и реалистично сменяется картинка на экране)
fps = pygame.time.Clock()

#координаты яблока
fruit_x = 300
fruit_y = 400

#список доступных яблок вместе с шансом выпадения какого-то определённого.
#то есть, красное яблоко может выпасть в четырёх случаях из семи, золотое - в двух, зелёное - только в одном.
apple_list = ["red_apple", "red_apple", "red_apple", "red_apple", "gold_apple", "gold_apple", "green_apple"]

#случайный выбор яблока из предоставленного списка
apple_choice = random.choice(apple_list)

#первоначальный счёт, который изменяется по мере прохождения игры
score = 0

#функция проигрыша, её мы будем активировать позже и при необходимых условиях 
def game_over():
    #"скрываем" змейку и яблоко, а на деле просто заливаем игровое поле цветом фона
    screen.fill(back_moccasin)

    #создаём индивидуальные надписи для каждого случая проигрыша
    # 1. Если из-за переедания зелёных яблок змейка уменьшилась настолько, что удалились все блоки из списка, делаем следующее:
    if len(snake_blocks) == 0:
        #создаём переменную game_over_font, где задаём шрифт надписи и её размер
        game_over_font = pygame.font.SysFont('bahnschrift', 30)
        #задаём текст, который будет отображаться.
        #в скобках начала указываем конкретный текст,
        #затем True или False (необходимо для сглаживания: если True, тогда текст будет гладким, False - резким),
        #а третий аргумент - цвет текста, его мы указали почти в самом начале кода
        game_over_reason = game_over_font.render('Упс! Змейка отравилась зелёными яблоками.', True, gameover_font_blue)

    # 2. Если координаты змейки совпадают с координатами границ окна:
    #(по очереди: если координаты змейки врезались или в левый край, или правый, или верхний, или нижний)
    #мы отнимаем от размеров окна 10, чтобы змейка наверняка не зашла за край
    if snake_x < 0 or snake_x > window_x-10 or snake_y < 0 or snake_y > window_y-10:
        #задаём в прошлом условии созданной переменной то же значение, только меняем размер текста
        #необязательно именно размер 40, можно до условий прописать эту переменную одной строкой (и, допустим, размер 30)
        #и тогда не упоминать эту переменную в каждом условии, но я сделала это для более красивого отображения
        game_over_font = pygame.font.SysFont('bahnschrift', 40)
        #делаем всё то же самое, что в прошлом условии, только меняем саму надпись
        game_over_reason = game_over_font.render('Упс! Змейка врезалась в стенку.', True, gameover_font_blue)

    # 3. Если змейка касается своего хвоста:
    #для начала создаём цикл, где перебираем каждый блок змейки, кроме последнего элемента, который является её головой 
    for x in snake_blocks[:-1]:
        #если же один из блоков равен координатам головы змейки (то есть, если змейка врезалась головой в хвост),
        if x == snake_head:
            #тогда создаём всю ту же переменную
            game_over_font = pygame.font.SysFont('bahnschrift', 40)
            #и вновь повторяем всё то же самое, только меняем саму надпись
            game_over_reason = game_over_font.render('Упс! Змейка запуталась в хвосте.', True, gameover_font_blue)
    
    #теперь задаём текст с отображением итогового счёта, который будет отображаться в любом из случаев
    #отличается от предыдущих только надписью и тем, что к тексту мы прибавляем переменную счёта
    #в остальном же всё повторяется: сглаживание и цвет  
    game_over_surface = game_over_font.render('Итоговый счёт: ' + str(score), True, gameover_font_blue)

    #задаём отдельной переменной стиль для надписи строкой ниже, в которой мы меняем только надпись и используемую переменную-стиль
    game_over_font_loop = pygame.font.SysFont('bahnschrift', 23)
    game_over_loop = game_over_font_loop.render('Нажмите Enter, чтобы продолжить, или Escape для выхода.', True, gameover_font_blue)
    
    #создаём прямоугольную область для надписи, которая выводится на экран и уже на неё "лепится" текст
    #сначала это текст "причины" проигрыша, это мы расписывали выше в условиях
    game_over_reason_rect = game_over_reason.get_rect()
    #затем это итоговый счёт
    game_over_rect = game_over_surface.get_rect()
    #и надпись с вариантами действий
    game_over_loop_rect = game_over_loop.get_rect()
        
    #устанавливаем расположение надписи (делим размеры окна на определённые числа, чтобы добиться желаемого расположения)
    #если есть желание, значения чисел можно без страха поменять
    #сначала располагаем текст с вариантами действий (а точнее, прямоугольную область для текста)
    game_over_loop_rect.midtop = (window_x/2, window_y/15)
    #теперь текст причины проигрыша 
    game_over_reason_rect.midtop = (window_x/2, window_y/2.7)
    #и располагаем итоговый счёт
    game_over_rect.midtop = (window_x/2.05, window_y/2)
        
    #и теперь выводим на экран текст на указанных выше прямоугольных областях
    screen.blit(game_over_loop, game_over_loop_rect)
    screen.blit(game_over_reason, game_over_reason_rect)
    screen.blit(game_over_surface, game_over_rect)

    #прописываем обновление экрана, чтобы функция работала
    #иначе при проигрыше игра просто застынет на месте и функция не отобразится
    pygame.display.update()
  
#функция отображения счёта в верхнем левом углу в процессе игры
def show_score():
    #создаём переменную game_over_font, где задаём шрифт надписи и её размер
    score_font = pygame.font.SysFont('comicsansms', 20)
      
    #задаём текст, который будет отображаться.
    #в скобках начала указываем сам текст, который необходимо вывести, и прибавляем переменную со счётом
    #эта переменная будет увеличиваться и изначально она хранится в числовом варианте,
    #но чтобы вывести эту переменную на экран, мы превращаем её в строчный тип и таким образом выводим на экран
    #затем True или False (необходимо для сглаживания: если True, тогда текст будет гладким, False - резким),
    #а третий аргумент - цвет текста, его мы указали почти в самом начале кода
    score_surface = score_font.render('Общий счёт: ' + str(score), True, score_font_brown)
      
    #создаём прямоугольную область для надписи, которая выводится на экран и уже на неё "лепится" текст
    score_rect = score_surface.get_rect()
    
    #и теперь выводим на экран текст на вышеуказанной прямоугольной области
    screen.blit(score_surface, score_rect)

#переменные, которые называются "флагами"; от их значения зависят определённые части кода
intro = True
game = True

#цикл главного экрана
#он действует, пока вышеупомянутая переменная intro не равна False, т.е. пока она равна True
while intro != False:
    #это обработка событий.
    #прописывая pygame.event.get(), мы получаем список всех событий, происходящих в данный момент с программой
    #и перебираем каждый элемент (событие) в полученном списке, выполняя следующее:
    for event in pygame.event.get():
        #если тип события - нажатие на крестик,
        if event.type == pygame.QUIT:
            #тогда мы делаем оба флага равными False, чтобы прекратить цикл главного меню и не запускать игровой цикл,
            #который, в свою очередь, зависит от флага game
            intro = False
            game = False
            #окно закрывается
            pygame.quit()

        #если же тип события равен нажатию на кнопку:
        elif event.type == pygame.KEYDOWN:
            #если была нажата клавиша Enter,
            if event.key == pygame.K_RETURN:
                #тогда мы задаём флагу intro значение False, чтобы прекратить цикл главного меню
                #тем не менее, флаг game остаётся равным True
                #простыми словами, это значит, что нажатием на Enter мы начинаем игру
                intro = False
            
            #если же была нажата клавиша Escape,
            elif event.key == pygame.K_ESCAPE:
                #мы делаем оба флага равными False,
                #таким образом прекращая цикл главного меню и не начиная главный игровой цикл
                #то есть, мы просто прекращаем игру
                intro = False
                game = False
                #а тут окно закрывается
                pygame.quit()

    #если же флаг intro не равен False (и равен True), тогда выводим на экран само главное меню, и вот как мы это делаем:
    if intro != False:
        #для начала заливаем фон цветом, который находится так же в начале кода    
        screen.fill(start_screen_back)

        #создаём переменные, где, опять же, указываем сам шрифт и его размер
        #нам необходимо две таких переменных, потому что первая - название игры большим шрифтом,
        #а вторая - варианты действий (нажать на Enter для продолжения либо же Escape для выхода), меньшим шрифтом
        snake_text_font = pygame.font.SysFont('freesansbold', 130)
        continue_quit_text_font = pygame.font.SysFont('bahnschrift', 30)

        #создаём сами надписи, которые немножко позже выведем на экран вместе с их прямоугольными областями
        #название игры, сглаживание и цвет текста (указан почти в начале кода)
        snake_surface = snake_text_font.render('Змейка', True, snake_text)
        #вариант продолжения путём нажатия на Enter, сглаживание и цвет текста (указан почти в начале кода)
        continue_surface = continue_quit_text_font.render('Нажмите Enter, чтобы продолжить', True, continue_quit_text)
        #вариант выхода путём нажатия на Escape, сглаживание и цвет текста (указан почти в начале кода)
        quit_surface = continue_quit_text_font.render('Нажмите Esc, чтобы выйти', True, continue_quit_text)

        #создаём три прямоугольные области для трёх надписей, именно на эти области выведутся вышеупомянутые надписи
        snake_rect = snake_surface.get_rect()
        continue_rect = continue_surface.get_rect()
        quit_rect = quit_surface.get_rect()

        #устанавливаем расположение надписей (делим размеры окна на определённые числа, чтобы добиться желаемого расположения)
        #если есть желание, значения чисел можно без страха поменять
        #располагаем текст названия игры (а точнее, прямоугольную область для текста)
        snake_rect.midtop = (window_x/2, window_y/5)

        #теперь то же самое, но только с надписью о нажатии на Enter
        continue_rect.midtop = (window_x/2, window_y/1.8)

        #и с нажатием на Escape
        quit_rect.midtop = (window_x/2, window_y/1.5)

        #все три надписи отобразятся на экране, но перед этим выведутся на собственные прямоугольные области
        screen.blit(snake_surface, snake_rect)
        screen.blit(continue_surface, continue_rect)
        screen.blit(quit_surface, quit_rect)

        #обновляем экран, чтобы главное меню вообще начало отображаться
        pygame.display.update()

#устанавливаем изначальное направление змейки (вниз),
direction = 'DOWN'
#а затем присваиваем второй переменной предыдущую (всё это будет необходимо в самом игровом цикле)
#эти две переменные являются лишь так называемыми переключателями,
#в зависимости от значения которых будет прописываться само изменение координат змейки в нужном направлении
#то есть, они сами ничего не меняют, но они влияют на то, как именно что-то будет меняться
change_to = direction

#сам игровой цикл, который начинается после завершения цикла главного меню
#если переменная game не равна False, тогда весь игровой процесс начинает происходить
while game != False:
    #как и в цикле с главным меню, создаём список событий и перебираем в нём каждый элемент (событие)
    for event in pygame.event.get():
        #если тип события равен нажатию на клавишу:
        if event.type == pygame.KEYDOWN:
            #если была нажата клавиша вверх, присваиваем переменной change_to значение UP
            if event.key == pygame.K_UP:
                change_to = 'UP'
            #если была нажата клавиша вниз, присваиваем переменной change_to значение DOWN
            if event.key == pygame.K_DOWN:
                change_to = 'DOWN'
            #если была нажата клавиша влево, присваиваем переменной change_to значение LEFT
            if event.key == pygame.K_LEFT:
                change_to = 'LEFT'
            #если была нажата клавиша вправо, присваиваем переменной change_to значение RIGHT
            #мы делаем это потому, что эта переменная будет одним из важных условий выбора направления
            if event.key == pygame.K_RIGHT:
                change_to = 'RIGHT'

        #если нажать на крестик (тип события равен нажатию на крестик), то игровой цикл прекратится и окно закроется
        if event.type == pygame.QUIT:
            game = False
  
    #запрещаем нажатие противоположных клавиш
    #нас здесь нужны две переменные, чтобы одну из них сравнивать с определённым значением,
    #а второй "отрезать" противоположное значение (вниз-вверх, вправо-влево) и в итоге приравнивать её к значению change_to,
    #что будет верно, поскольку значение переменной change_to мы делали в зависимости от нажатых клавиш
    #если change_to имеет значение вверх, тогда direction не сможет быть равна направлению вниз
    #и в любом случае, когда change_to становится равной направлению вверх (что равно нажатию на нужную клавишу),
    #вторая переменная будет равна только направлению вверх
    if change_to == 'UP' and direction != 'DOWN':
        direction = 'UP'
    #если change_to имеет значение вниз, тогда direction не сможет быть равна направлению вверх
    #и в любом случае становится равной направлению вниз
    if change_to == 'DOWN' and direction != 'UP':
        direction = 'DOWN'
    #если change_to имеет значение влево, тогда direction не сможет быть равна направлению вправо
    #и в любом случае становится равной направлению влево
    if change_to == 'LEFT' and direction != 'RIGHT':
        direction = 'LEFT'
    #если change_to имеет значение вправо, тогда direction не сможет быть равна направлению влево
    #и в любом случае становится равной направлению вправо
    if change_to == 'RIGHT' and direction != 'LEFT':
        direction = 'RIGHT'
  
    #движение змейки
    #если полученная путём вышеупомянутых махинаций переменная direction имеет значение вверх,
    #тогда меняем координаты змейки вверх, отнимая 10 от упомянутой в верхней части кода переменной
    if direction == 'UP':
        snake_y -= 10
    #если переменная direction имеет значение вниз,
    #тогда меняем координаты змейки вниз
    if direction == 'DOWN':
        snake_y += 10
    #если переменная direction имеет значение влево,
    #тогда меняем координаты змейки влево
    if direction == 'LEFT':
        snake_x -= 10
    #если переменная direction имеет значение вправо,
    #тогда меняем координаты змейки вправо
    if direction == 'RIGHT':
        snake_x += 10

    #ставим цвет фона (цвет указан почти в начале кода)
    screen.fill(back_moccasin)

    #чтобы размер блоков змейки изначально не увеличивался бесконечно и оставался равным переменной со значением длины змейки;
    #если длина списка блоков змейки становится больше, чем заданная длина змейки, мы удаляем из списка блоков один блок
    #если этого не сделать, то каждое обновление экрана змейка будет бесконечно расти, а нам это не нужно
    if len(snake_blocks) > snake_length:
        del snake_blocks[0]

    #первый список - один блок (голова)
    #следующие две строки добавляют в этот список координаты этого блока
    #на четвёртой строке готовый блок с координатами добавляется в рбщий список блоков змейки 
    snake_head = []
    snake_head.append(snake_x)
    snake_head.append(snake_y)
    snake_blocks.append(snake_head)

    #выводим на экран область, на которой уже будут рисоваться змейка и яблоки
    #чтобы это сделать, мы перебираем каждый блок в списке блоков змейки и вырисовываем таким образом всю змейку
    for block in snake_blocks:
        #как вырисовывается? Всё довольно просто.
        #в скобках указывается, куда именно выведется данная область
        #(в нашем случае на screen - наш экран; это переменная почти в начале кода)
        #дальше мы задаём цвет змейке, он тоже был указан почти в начале кода
        #после этого указываем координаты змейки. Здесь мы обращаемся к элементу списка блоков, ещё и по индексу,
        #потому что сам элемент-блок хранит в себе внутри ещё один список, где уже хранятся координаты данного блока.
        #Иными словами, задавая координаты одному блоку змейки, мы обращаемся к первому элементу его внутреннего списка,
        #чем является координата по оси x, и потом ко второму элементу, что уже является координатой по оси y
        #а потом задаём размеры этой области, эту переменную мы указали тоже примерно в первых переменных
        pygame.draw.rect(screen, snake_green, [block[0], block[1], snake_size, snake_size])

    #если из списка представленных яблок выбралось красное,
    if apple_choice == "red_apple":
        #теперь повторяем всё то же самое, что было для змейки, только для области вывода яблока,
        #и координаты мы уже указывали вверху кода
        pygame.draw.rect(screen, apple_red, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт увеличивается на один,
            score += 1
            #к условной длине змейки прибавляется один блок, но это работает так,
            #что по значению этой переменной уравнивается количество блоков в списке блоков змейки (уже описано выше)
            snake_length += 1
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)

    #если из списка представленных яблок выбралось золотое,
    elif apple_choice == "gold_apple":
        #вышепредставленным способом отрисовываем яблоко, только меняем цвет на золотой
        pygame.draw.rect(screen, apple_gold, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт увеличивается на четыре,
            score += 4
            #к условной длине змейки прибавляется четыре блока
            snake_length += 4
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)

    #если из списка представленных яблок выбралось зелёное,
    elif apple_choice == "green_apple":
        #вышепредставленным способом отрисовываем яблоко, только меняем цвет на зелёный
        pygame.draw.rect(screen, apple_green, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт будет уменьшаться только если он больше нуля,
            if score > 0:
                score -= 1
            #ниже нуля счёт не опустится, всё останется без изменений
            else:
                pass
            #от условной длины змейки удаляется один блок
            snake_length -= 1
            #и для полного осуществления этого удаляем первый блок из списка блоков змейки
            snake_blocks.pop(0)
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)
            #но если из-за слишком большого количества съеденных зелёных яблок змейка удалилась полностью,
            #то есть, если длина списка блоков стла равна нулю,
            if len(snake_blocks) == 0:
                #тогда мы задаём флагу game значение False, тем самым прерывая весь игровой цикл,
                game = False
                #но вместе с этим создаём флаг game_loop, от которого зависит цикл ниже
                game_loop = True
                #вот этот цикл.
                #мы делаем его для того, чтобы игру не приходилось постоянно перезапускать, а можно было начать заново сразу в игре
                #пока флаг game_loop равен True, выполняем следующее:
                while game_loop == True:
                    #активируем функцию с надписями для проигрыша
                    game_over()
                    #создаём список событий и перебираем в нём каждый элемент (событие)
                    for event in pygame.event.get():
                        #если тип события равен нажатию на клавишу:
                        if event.type == pygame.KEYDOWN:
                            #если была нажата клавиша Enter, тогда сбрасываем все переменные к исходному виду:
                            if event.key == pygame.K_RETURN:
                                #направление в две переменные
                                direction = 'DOWN'
                                change_to = direction
                                #список блоков
                                snake_blocks = []
                                #первоначальная длина змейки
                                snake_length = 4
                                #первоначальные координаты змейки
                                snake_x = window_x / 2
                                snake_y = window_y / 2
                                #выбор случайного яблока
                                apple_choice = random.choice(apple_list)
                                #изначальные координаты яблока
                                fruit_x = 300
                                fruit_y = 400
                                #сбрасываем счёт
                                score = 0
                                #задаём флагу game_loop значение False, чтобы остановить этот цикл
                                game_loop = False
                                #и задаём флагу game значение True, чтобы снова запустить игровой цикл
                                game = True
                            #если же была нажата клавиша Escape,
                            elif event.key == pygame.K_ESCAPE:
                                #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                                game_loop = False
                                #закрываем игровое окно
                                pygame.quit()
                        #если нажать на крестик (тип события равен нажатию на крестик), то игровой цикл прекратится и окно закроется
                        elif event.type == pygame.QUIT:
                            #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                            game_loop = False
                            #закрываем игровое окно
                            pygame.quit()

    #проверка, касается ли змейка своего хвоста
    #для начала создаём цикл, где перебираем каждый блок змейки, кроме последнего элемента, который является её головой 
    for x in snake_blocks[:-1]:
        #если же один из блоков равен координатам головы змейки (то есть, если змейка врезалась головой в хвост),
        if x == snake_head:
            #тогда мы задаём флагу game значение False, тем самым прерывая весь игровой цикл,
            game = False
            #но вместе с этим создаём флаг game_loop, от которого зависит цикл ниже
            game_loop = True
            #пока флаг game_loop равен True, выполняем следующее:
            while game_loop == True:
                #активируем функцию с надписями для проигрыша
                game_over()
                #создаём список событий и перебираем в нём каждый элемент (событие)
                for event in pygame.event.get():
                    #если тип события равен нажатию на клавишу:
                    if event.type == pygame.KEYDOWN:
                        #если была нажата клавиша Enter, тогда сбрасываем все переменные к исходному виду:
                        if event.key == pygame.K_RETURN:
                            #направление в две переменные
                            direction = 'DOWN'
                            change_to = direction
                            #список блоков
                            snake_blocks = []
                            #первоначальная длина змейки
                            snake_length = 4
                            #первоначальные координаты змейки
                            snake_x = window_x / 2
                            snake_y = window_y / 2
                            #выбор случайного яблока
                            apple_choice = random.choice(apple_list)
                            #изначальные координаты яблока
                            fruit_x = 300
                            fruit_y = 400
                            #сбрасываем счёт
                            score = 0
                            #задаём флагу game_loop значение False, чтобы остановить этот цикл
                            game_loop = False
                            #и задаём флагу game значение True, чтобы снова запустить игровой цикл
                            game = True
                        #если же была нажата клавиша Escape,
                        elif event.key == pygame.K_ESCAPE:
                            #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                            game_loop = False
                            #закрываем игровое окно
                            pygame.quit()
                    #если нажать на крестик (тип события равен нажатию на крестик), то игровой цикл прекратится и окно закроется
                    elif event.type == pygame.QUIT:
                        #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                        game_loop = False
                        #закрываем игровое окно
                        pygame.quit()

    #если змейка касается левого/правого края окна или верхнего/нижнего,
    if snake_x < 0 or snake_x > window_x-10 or snake_y < 0 or snake_y > window_y-10:
        #тогда мы задаём флагу game значение False, тем самым прерывая весь игровой цикл,
        game = False
        #но вместе с этим создаём флаг game_loop, от которого зависит цикл ниже
        game_loop = True
        #вот этот цикл.
        #мы делаем его для того, чтобы игру не приходилось постоянно перезапускать, а можно было начать заново сразу в игре
        #пока флаг game_loop равен True, выполняем следующее:
        while game_loop == True:
            #активируем функцию с надписями для проигрыша
            game_over()
            #создаём список событий и перебираем в нём каждый элемент (событие)
            for event in pygame.event.get():
                #если тип события равен нажатию на клавишу:
                if event.type == pygame.KEYDOWN:
                    #если была нажата клавиша Enter, тогда сбрасываем все переменные к исходному виду:
                    if event.key == pygame.K_RETURN:
                        #направление в две переменные
                        direction = 'DOWN'
                        change_to = direction
                        #список блоков
                        snake_blocks = []
                        #первоначальная длина змейки
                        snake_length = 4
                        #первоначальные координаты змейки
                        snake_x = window_x / 2
                        snake_y = window_y / 2
                        #выбор случайного яблока
                        apple_choice = random.choice(apple_list)
                        #изначальные координаты яблока
                        fruit_x = 300
                        fruit_y = 400
                        #сбрасываем счёт
                        score = 0
                        #задаём флагу game_loop значение False, чтобы остановить этот цикл
                        game_loop = False
                        #и задаём флагу game значение True, чтобы снова запустить игровой цикл
                        game = True
                    #если же была нажата клавиша Escape,
                    elif event.key == pygame.K_ESCAPE:
                        #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                        game_loop = False
                        #закрываем игровое окно
                        pygame.quit()
                #если нажать на крестик (тип события равен нажатию на крестик), то игровой цикл прекратится и окно закроется
                elif event.type == pygame.QUIT:
                    #задаём флагу game_loop значение False, чтобы остановить этот цикл и не возникло ошибок
                    game_loop = False
                    #закрываем игровое окно
                    pygame.quit()

    #обновляем фпс, чтобы происходящее двигалось нормально
    #в данном случае фпс равно скорости змейки (переменная в начале кода)
    fps.tick(snake_speed)
    
    #если флаг игрового цикла game всё же не равен False, то есть равен True,
    if game != False:
        #тогда запускаем функцию отображения счёта в момент игры
        show_score()
        #обновляем экран, чтобы всё работало и не зависло
        pygame.display.update()