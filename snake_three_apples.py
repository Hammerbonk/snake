#подключаем библиотеки, с которыми мы будем работать
import pygame
import time
import random

#инициализация; необходимо для корректной работы всех модулей данной библиотеки
pygame.init()

#необходимые цвета, которые мы будем использовать в ходе написания кода
start_screen_back = (50, 205, 50)
snake_text = (0, 128, 0)
continue_quit_text = (0, 90, 0)
back_moccasin = (255, 228, 181)
score_font_brown = (139, 69, 19)
gameover_font_blue = (65, 105, 225)
snake_green = (0, 100, 0)
apple_red = (255, 0, 0)
apple_gold = (255, 165, 0)
apple_green = (35, 129, 0)

#задаём размеры,
window_x = 720
window_y = 480

#cоздаём окно размером заданных чисел
screen = pygame.display.set_mode((window_x, window_y))

#и его название
pygame.display.set_caption('Grisha')

#ставим змейку в середину экрана, и для этого разделяем указанные значения пополам
snake_x = window_x / 2
snake_y = window_y / 2

#размер блока змейки
snake_size = 10

#длина змейки
snake_length = 4

#список, в котором хранятся все её блоки
snake_blocks = []

#скорость змейки (используем для фпс)
snake_speed = 15

#фпс (кадры в секунду), без них игра моментально закончится, так как не будет задана скорость отображения
#(показатель того, насколько плавно и реалистично сменяется картинка на экране)
fps = pygame.time.Clock()

#координаты яблока
fruit_x = 300
fruit_y = 400

#переменные для передвижения, их мы будем прибавлять к координатам змейки и таким образом она будет двигаться
speed_x = 0
speed_y = 10

#список доступных яблок вместе с шансом выпадения какого-то определённого.
#то есть, красное яблоко может выпасть в четырёх случаях из семи, золотое - в двух, зелёное - только в одном.
apple_list = ["red_apple", "red_apple", "red_apple", "red_apple", "gold_apple", "gold_apple", "green_apple"]

#случайный выбор яблока из предоставленного списка
apple_choice = random.choice(apple_list)

#первоначальный счёт, который изменяется по мере прохождения игры
score = 0

#функция проигрыша, её мы будем активировать позже и при необходимых условиях 
def game_over():
    #"скрываем" змейку и яблоко, а на деле просто заливаем игровое поле цветом фона
    screen.fill(back_moccasin)

    #создаём индивидуальные надписи для каждого случая проигрыша
    # 1. Если из-за переедания зелёных яблок змейка уменьшилась настолько, что удалились все блоки из списка, делаем следующее:
    if len(snake_blocks) == 0:
        #создаём переменную game_over_font, где задаём шрифт надписи и её размер
        game_over_font = pygame.font.SysFont('bahnschrift', 30)
        #задаём текст, который будет отображаться.
        #в скобках начала указываем конкретный текст,
        #затем True или False (необходимо для сглаживания: если True, тогда текст будет гладким, False - резким),
        #а третий аргумент - цвет текста, его мы указали почти в самом начале кода
        game_over_reason = game_over_font.render('Упс! Змейка отравилась зелёными яблоками.', True, gameover_font_blue)

    # 2. Если координаты змейки совпадают с координатами границ окна:
    #(по очереди: если координаты змейки врезались или в левый край, или правый, или верхний, или нижний)
    #мы отнимаем от размеров окна 10, чтобы змейка наверняка не зашла за край
    if snake_x < 0 or snake_x > window_x-10 or snake_y < 0 or snake_y > window_y-10:
        #задаём в прошлом условии созданной переменной то же значение, только меняем размер текста
        #необязательно именно размер 40, можно до условий прописать эту переменную одной строкой (и, допустим, размер 30)
        #и тогда не упоминать эту переменную в каждом условии, но я сделала это для более красивого отображения
        game_over_font = pygame.font.SysFont('bahnschrift', 40)
        #делаем всё то же самое, что в прошлом условии, только меняем саму надпись
        game_over_reason = game_over_font.render('Упс! Змейка врезалась в стенку.', True, gameover_font_blue)

    # 3. Если змейка касается своего хвоста:
    #для начала создаём цикл, где перебираем каждый блок змейки, кроме последнего элемента, который является её головой 
    for x in snake_blocks[:-1]:
        #если же один из блоков равен координатам головы змейки (то есть, если змейка врезалась головой в хвост),
        if x == snake_head:
            #тогда создаём всю ту же переменную
            game_over_font = pygame.font.SysFont('bahnschrift', 40)
            #и вновь повторяем всё то же самое, только меняем саму надпись
            game_over_reason = game_over_font.render('Упс! Змейка запуталась в хвосте.', True, gameover_font_blue)
    
    #теперь задаём текст с отображением итогового счёта, который будет отображаться в любом из случаев
    #отличается от предыдущих только надписью и тем, что к тексту мы прибавляем переменную счёта
    #в остальном же всё повторяется: сглаживание и цвет  
    game_over_surface = game_over_font.render('Итоговый счёт: ' + str(score), True, gameover_font_blue)
    
    #создаём прямоугольную область для надписи, которая выводится на экран и уже на неё "лепится" текст
    #сначала это текст "причины" проигрыша, это мы расписывали выше в условиях
    game_over_reason_rect = game_over_reason.get_rect()
    #затем это итоговый счёт
    game_over_rect = game_over_surface.get_rect()
        
    #устанавливаем расположение надписи (делим размеры окна на определённые числа, чтобы добиться желаемого расположения)
    #если есть желание, значения чисел можно без страха поменять
    #располагаем текст причины проигрыша (а точнее, прямоугольную область для текста)
    game_over_reason_rect.midtop = (window_x/2, window_y/2.7)
    #а теперь располагаем итоговый счёт
    game_over_rect.midtop = (window_x/2.05, window_y/2)
        
    #и теперь выводим на экран текст на указанных выше прямоугольных областях
    screen.blit(game_over_reason, game_over_reason_rect)
    screen.blit(game_over_surface, game_over_rect)

    #прописываем обновление экрана, чтобы функция работала
    #иначе при проигрыше игра просто застынет на месте и функция не отобразится
    pygame.display.update()
        
    #после семи секунд программа автоматически выключится
    time.sleep(7)
        
    #деактивация библиотеки pygame (то есть, выключение окна)
    pygame.quit()
  
#функция отображения счёта в верхнем левом углу в процессе игры
def show_score():
    
    #создаём переменную game_over_font, где задаём шрифт надписи и её размер
    score_font = pygame.font.SysFont('comicsansms', 20)
      
    #задаём текст, который будет отображаться.
    #в скобках начала указываем сам текст, который необходимо вывести, и прибавляем переменную со счётом
    #эта переменная будет увеличиваться и изначально она хранится в числовом варианте,
    #но чтобы вывести эту переменную на экран, мы превращаем её в строчный тип и таким образом выводим на экран
    #затем True или False (необходимо для сглаживания: если True, тогда текст будет гладким, False - резким),
    #а третий аргумент - цвет текста, его мы указали почти в самом начале кода
    score_surface = score_font.render('Общий счёт: ' + str(score), True, score_font_brown)
      
    #создаём прямоугольную область для надписи, которая выводится на экран и уже на неё "лепится" текст
    score_rect = score_surface.get_rect()
    
    #и теперь выводим на экран текст на указанной выше прямоугольной области
    screen.blit(score_surface, score_rect)

#переменные, которые называются "флагами"; от их значения зависят определённые части кода
intro = True
game = True

#цикл главного экрана
#он действует, пока вышеупомянутая переменная intro не равна False, т.е. пока она равна True
while intro != False:
    #это обработка событий.
    #прописывая pygame.event.get(), мы получаем список всех событий, происходящих в данный момент с программой
    #и перебираем каждый элемент (событие) в полученном списке, выполняя следующее:
    for event in pygame.event.get():
        #если тип события - нажатие на крестик,
        if event.type == pygame.QUIT:
            #тогда мы делаем оба флгами равными False, чтобы прекратить цикл главного меню и не запускать игровой цикл,
            #который, в свою очередь, зависит от флага game
            intro = False
            game = False
            #окно закрывается
            pygame.quit()

        #если же тип события равен нажатию на кнопку:
        elif event.type == pygame.KEYDOWN:
            #если была нажата клавиша Enter,
            if event.key == pygame.K_RETURN:
                #тогда мы задаём флагу intro значение False, чтобы прекратить цикл главного меню
                #тем не менее, флаг game остаётся равным True
                #простыми словами, это значит, что нажатием на Enter мы начинаем игру
                intro = False
            
            #если же была нажата клавиша Escape,
            elif event.key == pygame.K_ESCAPE:
                #мы делаем оба флага равными False,
                #таким образом прекращая цикл главного меню и не начиная главный игровой цикл
                #то есть, мы просто прекращаем игру
                intro = False
                game = False
                #а тут окно закрывается
                pygame.quit()

    #если же флаг intro не равен False (и равен True), тогда выводим на экран само главное меню, и вот как мы это делаем:
    if intro != False:
        #для начала заливаем фон цветом, который находится так же в начале кода    
        screen.fill(start_screen_back)

        #создаём переменные, где, опять же, указываем сам шрифт и его размер
        #нам необходимо две таких переменных, потому что первая - название игры большим шрифтом,
        #а вторая - варианты действий (нажать на Enter для продолжения либо же Escape для выхода), меньшим шрифтом
        snake_text_font = pygame.font.SysFont('freesansbold', 130)
        continue_quit_text_font = pygame.font.SysFont('bahnschrift', 30)

        #создаём сами надписи, которые немножко позже выведем на экран вместе с их прямоугольными областями
        #название игры, сглаживание и цвет текста (указан почти в начале кода)
        snake_surface = snake_text_font.render('Змейка', True, snake_text)
        #вариант продолжения путём нажатия на Enter, сглаживание и цвет текста (указан почти в начале кода)
        continue_surface = continue_quit_text_font.render('Нажмите Enter, чтобы продолжить', True, continue_quit_text)
        #вариант выхода путём нажатия на Escape, сглаживание и цвет текста (указан почти в начале кода)
        quit_surface = continue_quit_text_font.render('Нажмите Esc, чтобы выйти', True, continue_quit_text)

        #создаём три прямоугольные области для трёх надписей, именно на эти области выведутся вышеупомянутые надписи
        snake_rect = snake_surface.get_rect()
        continue_rect = continue_surface.get_rect()
        quit_rect = quit_surface.get_rect()

        #устанавливаем расположение надписей (делим размеры окна на определённые числа, чтобы добиться желаемого расположения)
        #если есть желание, значения чисел можно без страха поменять
        #располагаем текст названия игры (а точнее, прямоугольную область для текста)
        snake_rect.midtop = (window_x/2, window_y/5)

        #теперь то же самое, но только с надписью о нажатии на Enter
        continue_rect.midtop = (window_x/2, window_y/1.8)

        #и с нажатием на Escape
        quit_rect.midtop = (window_x/2, window_y/1.5)

        #все три надписи отобразятся на экране, но перед этим выведутся на собственные прямоугольные области
        screen.blit(snake_surface, snake_rect)
        screen.blit(continue_surface, continue_rect)
        screen.blit(quit_surface, quit_rect)

        #обновляем экран, чтобы главное меню вообще начало отображаться
        pygame.display.update()

#переменные для направления змейки, и, можно сказать, так называемые флаги;
#необходимы для того, чтобы змейка не могла уходить в саму себя влево, когда, допустим, идёт вправо и т.д.
#в данном случае три переменные равны False и только одна равна True
#эта переменная будет отвечать за изначальное направление змейки: вниз
#первая переменная отвечает за нправление вверх, вторая - вниз, третья - вправо, четвёртая - влево 
move_up = False
move_down = True
move_right = False
move_left = False

#сам игровой цикл, который начинается после завершения цикла главного меню
#если переменная game не равна False, тогда весь игровой процесс начинает происходить
while game != False:
    #как и в цикле с главным меню, создаём список событий и перебираем в нём каждый элемент (событие)
    for event in pygame.event.get():
        #если тип события равен нажатию на клавишу:
        if event.type == pygame.KEYDOWN:
            #если была нажата клавиша вверх и направление вниз отключено (равно False в нашем случае),
            #что значит, что при нажатии вверх мы не сможем направить змейку прямо вниз (и она не сможет уйти сама в себя),
            #тогда всем переменным задаём значение False (отключаем), кроме переменной, отвечающей за направление вверх 
            if event.key == pygame.K_UP and move_down == False:
                move_up = True
                move_down = False
                move_right = False
                move_left = False
            #всё повторяется, только теперь если нажата клавиша вниз и направление вверх равно False
            if event.key == pygame.K_DOWN and move_up == False:
                move_up = False
                move_down = True
                move_right = False
                move_left = False
            #если нажата клавиша влево и направление вправо равно False
            if event.key == pygame.K_LEFT and move_right == False:
                move_up = False
                move_down = False
                move_right = False
                move_left = True
            #если нажата клавиша вправо и направление влево равно False
            if event.key == pygame.K_RIGHT and move_left == False:
                move_up = False
                move_down = False
                move_right = True
                move_left = False

        #если нажать на крестик (тип события равен нажатию на крестик), то игровой цикл прекратится и окно закроется
        if event.type == pygame.QUIT:
            game = False

    #один из двигателей змейки
    #если направление равно вверх,
    if move_up:
        #то горизонтально мы никак не меняем змейку,
        speed_x = 0
        #но двигаем её вертикально, а точнее вверх, задав переменной для оси y значение -10
        speed_y = -10
    #если направление равно вниз,
    if move_down:
        #то горизонтально мы никак не меняем змейку,
        speed_x = 0
        #но двигаем её вертикально, а точнее вниз, задав переменной для оси y значение 10
        speed_y = 10
    #если направление равно влево,
    if move_left:
        #то вертикально мы никак не меняем змейку,
        speed_y = 0
        #но двигаем её горизонтально, а точнее влево, задав переменной для оси x значение -10
        speed_x = -10
    #если направление равно вправо,
    if move_right:
        #то вертикально мы никак не меняем змейку,
        speed_y = 0
        #но двигаем её горизонтально, а точнее вправо, задав переменной для оси x значение 10
        speed_x = 10

    #ставим цвет фона (цвет указан почти в начале кода)
    screen.fill(back_moccasin)

    #первый список - один блок (голова)
    #следующие две строки добавляют в этот список координаты этого блока
    #на четвёртой строке готовый блок с координатами добавляется в рбщий список блоков змейки 
    snake_head = []
    snake_head.append(snake_x)
    snake_head.append(snake_y)
    snake_blocks.append(snake_head)

    #чтобы размер блоков змейки изначально не увеличивался бесконечно и оставался равным переменной со значением длины змейки;
    #если длина списка блоков змейки становится больше, чем заданная длина змейки, мы удаляем из списка блоков один блок
    #если этого не сделать, то каждое обновление экрана змейка будет бесконечно расти, а нам это не нужно
    if len(snake_blocks) > snake_length:
        del snake_blocks[0]

    #второй двигатель змейки: делаем так, чтобы змейка постоянно двигалась
    #то есть, к координатам змейки непрерывно прибавляются переменные, значение которых зависит от направления
    #направление мы расписали выше в обработке событий
    snake_x += speed_x
    snake_y += speed_y

    #выводим на экран область, на которой уже будут рисоваться змейка и яблоки
    #чтобы это сделать, мы перебираем каждый блок в списке блоков змейки и вырисовываем таким образом всю змейку
    for block in snake_blocks:
        #как вырисовывается? Всё довольно просто.
        #в скобках указывается, куда именно выведется данная область
        #(в нашем случае на screen - наш экран; это переменная почти в начале кода)
        #дальше мы задаём цвет змейке, он тоже был указан почти в начале кода
        #после этого указываем координаты змейки. Здесь мы обращаемся к элементу списка блоков, ещё и по индексу,
        #потому что сам элемент-блок хранит в себе внутри ещё один список, где уже хранятся координаты данного блока.
        #Иными словами, задавая координаты одному блоку змейки, мы обращаемся к первому элементу его внутреннего списка,
        #чем является координата по оси x, и потом ко второму элементу, что уже является координатой по оси y
        #а потом задаём размеры этой области, эту переменную мы указали тоже примерно в первых переменных
        pygame.draw.rect(screen, snake_green, [block[0], block[1], snake_size, snake_size])

    #если из списка представленных яблок выбралось красное,
    if apple_choice == "red_apple":
        #теперь повторяем всё то же самое, что было для змейки, только для области вывода яблока,
        #и координаты мы уже указывали вверху кода
        pygame.draw.rect(screen, apple_red, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт увеличивается на один,
            score += 1
            #к условной длине змейки прибавляется один блок, но это работает так,
            #что по значению этой переменной уравнивается количество блоков в списке блоков змейки (уже описано выше)
            snake_length += 1
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)

    #если из списка представленных яблок выбралось золотое,
    elif apple_choice == "gold_apple":
        #выше представленным способом отрисовываем яблоко, только меняем цвет на золотой
        pygame.draw.rect(screen, apple_gold, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт увеличивается на четыре,
            score += 4
            #к условной длине змейки прибавляется четыре блока
            snake_length += 4
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)

    #если из списка представленных яблок выбралось зелёное,
    elif apple_choice == "green_apple":
        #выше представленным способом отрисовываем яблоко, только меняем цвет на зелёный
        pygame.draw.rect(screen, apple_green, [fruit_x, fruit_y, snake_size, snake_size])

        #если змейка касается яблока (если совпадают их координаты),
        if snake_x == fruit_x and snake_y == fruit_y:
            #тогда координаты яблока обновляются на новые рандомные,
            fruit_x = round(random.randrange(0, window_x - snake_size) / 10) * 10
            fruit_y = round(random.randrange(0, window_y - snake_size) / 10) * 10
            #счёт будет уменьшаться только если он больше нуля,
            if score > 0:
                score -= 1
            #ниже нуля счёт не опустится, всё останется без изменений
            else:
                pass
            #от условной длины змейки удаляется один блок
            snake_length -= 1
            #и для полного осуществления этого удаляем первый блок из списка блоков змейки
            snake_blocks.pop(0)
            #выбирается новое яблоко из списка яблок
            apple_choice = random.choice(apple_list)
            #но если из-за слишком большого количества съеденных зелёных яблок змейка удалилась полностью,
            #то есть, если длина списка блоков стла равна нулю,
            if len(snake_blocks) == 0:
                #то мы задаём флагу game значение False, тем самым прерывая весь игровой цикл, 
                game = False
                #и активируется функция проигрыша, где уже выберется необходимая надпись и после этого закроется окно
                game_over()

    #проверка, касается ли змейка своего хвоста
    #для начала создаём цикл, где перебираем каждый блок змейки, кроме последнего элемента, который является её головой 
    for x in snake_blocks[:-1]:
        #если же один из блоков равен координатам головы змейки (то есть, если змейка врезалась головой в хвост),
        if x == snake_head:
            #тогда мы задаём флагу game значение False, тем самым прерывая весь игровой цикл,
            game = False
            #и активируется функция проигрыша, где уже выберется необходимая надпись и после этого закроется окно
            game_over()

    #если змейка касается левого/правого края окна или верхнего/нижнего,
    if snake_x < 0 or snake_x > window_x-10 or snake_y < 0 or snake_y > window_y-10:
        #тогда мы задаём флагу game значение False, тем самым прерывая весь игровой цикл,
        game = False
        #и активируется функция проигрыша, где уже выберется необходимая надпись и после этого закроется окно
        game_over()

    #обновляем фпс, чтобы происходящее двигалось нормально
    #в данном случае фпс равно скорости змейки (переменная в начале кода)
    fps.tick(snake_speed)
    
    #если флаг игрового цикла game всё же не равен False, то есть равен True,
    if game != False:
        #тогда запускаем функцию отображения счёта в момент игры
        show_score()
        #обновляем экран, чтобы всё работало и не зависло
        pygame.display.update()